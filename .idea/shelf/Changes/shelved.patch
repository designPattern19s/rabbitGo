Index: src/engine/src/rabbitescape/engine/behaviours/Bridging.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package rabbitescape.engine.behaviours;\n\nimport static rabbitescape.engine.ChangeDescription.State.*;\nimport static rabbitescape.engine.Token.Type.*;\nimport static rabbitescape.engine.Block.Material.*;\nimport static rabbitescape.engine.Block.Shape.*;\n\nimport java.util.Map;\n\nimport rabbitescape.engine.*;\nimport rabbitescape.engine.ChangeDescription.State;\n\npublic class Bridging extends Behaviour\n{\n    public enum BridgeType\n    {\n        ALONG,\n        UP,\n        DOWN_UP\n    }\n\n    private static Bridging instance;\n    private int smallSteps = 0;\n    private int bigSteps = 0;\n    private BridgeType bridgeType = BridgeType.ALONG;\n\n    private Bridging(){ }\n\n    public static Bridging getInstance() {\n        if (instance == null) {\n            instance = new Bridging();\n        }\n        return instance;\n    }\n\n    public void getVariables(RabbitBehaviourVariables vars) {\n        smallSteps = vars.smallSteps;\n        bigSteps = vars.bigSteps;\n        bridgeType = vars.bridgeType;\n    }\n\n    public void saveVariables(RabbitBehaviourVariables vars)\n    {\n        vars.smallSteps = smallSteps;\n        vars.bigSteps = bigSteps;\n        vars.bridgeType = bridgeType;\n    }\n\n    @Override\n    public void cancel()\n    {\n        bigSteps = 0;\n        smallSteps = 0;\n    }\n\n    @Override\n    public boolean checkTriggered( Rabbit rabbit, World world )\n    {\n        nextStep();\n\n        if ( bigSteps <= 0 )\n            // Only pick up a token if we've finished, and we can bridge\n        {\n            BehaviourTools t = BehaviourTools.getInstance( rabbit, world );\n            t.initialize( rabbit, world );\n\n            State possibleState = bridgingState( t, 3, 3, bridgeType );\n\n            if ( possibleState != null ) // Only pick up if we can bridge\n            {\n                return t.pickUpToken( bridge );\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public State newState( BehaviourTools t, boolean triggered )\n    {\n        if ( triggered )\n        {\n            smallSteps = 3;\n            bigSteps = 3;\n        }\n\n        State ret = bridgingState( t, bigSteps, smallSteps, bridgeType );\n\n        if ( ret == null )\n        {\n            bigSteps = 0;\n        }\n\n        if ( bigSteps <= 0 )\n        {\n            smallSteps = 0;\n            return null;   // Finished bridging\n        }\n\n        return ret;\n    }\n\n    private static State bridgingState(\n        BehaviourTools t,\n        int bs,\n        int ss,\n        BridgeType bt\n    )\n    {\n        Block hereBlock = t.blockHere();\n\n        Rabbit rabbit = t.rabbit;\n        World world = t.world;\n\n        if ( startingIntoToWall( world, rabbit, bs ) )\n        {\n            return stateIntoWall( t, rabbit, world, ss );\n        }\n\n        boolean slopeUp = isSlopeUp( rabbit, hereBlock );\n        int nx = nextX( rabbit );\n        int ny = nextY( rabbit, slopeUp );\n\n        Block nextBlock = world.getBlockAt( nx, ny );\n\n        Block belowNextBlock = world.getBlockAt( nx, rabbit.y );\n        Block twoAboveHereBlock = world.getBlockAt( rabbit.x, rabbit.y - 2 );\n        Block aboveNextBlock = world.getBlockAt( nx, ny - 1 );\n\n        if (\n            (\n                   // Something in the way\n                   nextBlock != null\n                && nextBlock.riseDir() != rabbit.dir\n            ) || (\n                   Blocking.blockerAt( t.world, nx, ny )\n            ) || (\n                   // Clip land\n                   belowNextBlock != null\n                && belowNextBlock.riseDir() != rabbit.dir\n            ) || (\n                    // Bang head next\n                    aboveNextBlock != null\n                 && BehaviourTools.isSolid( aboveNextBlock )\n            ) || (\n                    // Bang head here, mid-build\n                    bs < 3\n                 && BehaviourTools.s_isFlat( twoAboveHereBlock )\n            )\n        )\n        {\n            return null; // Stop bridging\n        }\n\n        boolean slopeDown = (\n               ( hereBlock != null )\n            && ( hereBlock.riseDir() == Direction.opposite( rabbit.dir ) )\n        );\n\n        switch( ss )\n        {\n            case 3:\n            {\n                if ( slopeUp )\n                {\n                    return t.rl(\n                        RABBIT_BRIDGING_UP_RIGHT_1,\n                        RABBIT_BRIDGING_UP_LEFT_1\n                    );\n                }\n                else if ( slopeDown )\n                {\n                    return t.rl(\n                        RABBIT_BRIDGING_DOWN_UP_RIGHT_1,\n                        RABBIT_BRIDGING_DOWN_UP_LEFT_1\n                    );\n                }\n                else\n                {\n                    return t.rl(\n                        RABBIT_BRIDGING_RIGHT_1,\n                        RABBIT_BRIDGING_LEFT_1\n                    );\n                }\n            }\n            case 2:\n            {\n                switch( bt )\n                {\n                    case ALONG:\n                    {\n                        return t.rl(\n                            RABBIT_BRIDGING_RIGHT_2,\n                            RABBIT_BRIDGING_LEFT_2\n                        );\n                    }\n                    case UP:\n                    {\n                        return t.rl(\n                            RABBIT_BRIDGING_UP_RIGHT_2,\n                            RABBIT_BRIDGING_UP_LEFT_2\n                        );\n                    }\n                    case DOWN_UP:\n                    {\n                        return t.rl(\n                            RABBIT_BRIDGING_DOWN_UP_RIGHT_2,\n                            RABBIT_BRIDGING_DOWN_UP_LEFT_2\n                        );\n                    }\n                    default:\n                    {\n                        throw new AssertionError(\n                            \"Unexpected bridge type: \" + bt );\n                    }\n                }\n            }\n            case 1:\n            {\n                switch( bt )\n                {\n                    case ALONG:\n                    {\n                        return t.rl(\n                            RABBIT_BRIDGING_RIGHT_3,\n                            RABBIT_BRIDGING_LEFT_3\n                        );\n                    }\n                    case UP:\n                    {\n                        return t.rl(\n                            RABBIT_BRIDGING_UP_RIGHT_3,\n                            RABBIT_BRIDGING_UP_LEFT_3\n                        );\n                    }\n                    case DOWN_UP:\n                    {\n                        return t.rl(\n                            RABBIT_BRIDGING_DOWN_UP_RIGHT_3,\n                            RABBIT_BRIDGING_DOWN_UP_LEFT_3\n                        );\n                    }\n                    default:\n                    {\n                        throw new AssertionError(\n                            \"Unexpected bridge type: \" + bt );\n                    }\n                }\n            }\n            default:\n            {\n                return null;\n            }\n        }\n    }\n\n    private static State stateIntoWall(\n        BehaviourTools t, Rabbit rabbit, World world, int ss )\n    {\n        // We are facing a wall.  This makes us a bit keener to\n        // bridge.\n        Block thisBlock = world.getBlockAt( rabbit.x, rabbit.y );\n\n        boolean slopeUp = isSlopeUp( rabbit, thisBlock );\n        int bx = behindX( rabbit );\n        int ny = nextY( rabbit, slopeUp );\n\n        // Don't bridge if there is no block behind us (we're not in a hole)\n        if ( isSlope( thisBlock ) && world.getBlockAt( bx, ny ) == null )\n        {\n            return null;\n        }\n\n        switch( ss )\n        {\n            case 3:\n            {\n                if ( isSlope( thisBlock ) )\n                {\n                    // Special behaviour where we bridge higher up because we\n                    // are already on top of a slope.\n\n                    Block twoAbove = world.getBlockAt( rabbit.x, rabbit.y - 2 );\n\n                    if ( twoAbove == null || twoAbove.isBridge() ) {\n                        return t.rl(\n                            RABBIT_BRIDGING_IN_CORNER_UP_RIGHT_1,\n                            RABBIT_BRIDGING_IN_CORNER_UP_LEFT_1\n                        );\n                    }\n                    else\n                    {\n                        // We would hit our head, so don't bridge.\n                        return null;\n                    }\n                }\n                else\n                {\n                    return t.rl(\n                        RABBIT_BRIDGING_IN_CORNER_RIGHT_1,\n                        RABBIT_BRIDGING_IN_CORNER_LEFT_1\n                    );\n                }\n            }\n            case 2:\n            {\n                if ( isSlope( thisBlock ) )\n                {\n                    return t.rl(\n                        RABBIT_BRIDGING_IN_CORNER_UP_RIGHT_2,\n                        RABBIT_BRIDGING_IN_CORNER_UP_LEFT_2\n                    );\n                }\n                else\n                {\n                    return t.rl(\n                        RABBIT_BRIDGING_IN_CORNER_RIGHT_2,\n                        RABBIT_BRIDGING_IN_CORNER_LEFT_2\n                    );\n                }\n            }\n            case 1:\n            {\n                if ( isSlope( thisBlock ) )\n                {\n                    return t.rl(\n                        RABBIT_BRIDGING_IN_CORNER_UP_RIGHT_3,\n                        RABBIT_BRIDGING_IN_CORNER_UP_LEFT_3\n                    );\n                }\n                else\n                {\n                    return t.rl(\n                        RABBIT_BRIDGING_IN_CORNER_RIGHT_3,\n                        RABBIT_BRIDGING_IN_CORNER_LEFT_3\n                    );\n                }\n            }\n            default:\n            {\n                return null;\n            }\n        }\n    }\n\n    private static boolean startingIntoToWall(\n        World world,\n        Rabbit rabbit,\n        int bs\n    )\n    {\n        Block hereBlock = world.getBlockAt( rabbit.x, rabbit.y );\n\n        boolean slopeUp = isSlopeUp( rabbit, hereBlock );\n        int nx = nextX( rabbit );\n        int ny = nextY( rabbit, slopeUp );\n\n        Block nextBlock = world.getBlockAt( nx, ny );\n\n        return (\n           bs == 3\n        )\n        &&\n        (\n               nextBlock != null\n            &&\n            (\n                   nextBlock.riseDir() != rabbit.dir\n                || nextBlock.shape == FLAT\n            )\n         );\n    }\n\n    private static boolean isSlopeUp( Rabbit rabbit, Block hereBlock )\n    {\n        return ( hereBlock != null )\n          && ( hereBlock.riseDir() == rabbit.dir );\n    }\n\n    private static int nextY( Rabbit rabbit, boolean slopeUp )\n    {\n        int ret = rabbit.y;\n        ret += slopeUp ? -1 : 0;\n        return ret;\n    }\n\n    private static int nextX( Rabbit rabbit )\n    {\n        int ret = rabbit.x;\n        ret += rabbit.dir == Direction.RIGHT ? 1 : -1;\n        return ret;\n    }\n\n    private static int behindX( Rabbit rabbit )\n    {\n        int ret = rabbit.x;\n        ret += rabbit.dir == Direction.RIGHT ? -1 : 1;\n        return ret;\n    }\n\n    private void nextStep()\n    {\n        --smallSteps;\n        if ( smallSteps <= 0 )\n        {\n            --bigSteps;\n            smallSteps = 3;\n        }\n    }\n\n    private static boolean isSlope( Block thisBlock )\n    {\n        return ( thisBlock != null && thisBlock.shape != FLAT );\n    }\n\n    @Override\n    public boolean behave( World world, Rabbit rabbit, State state )\n    {\n        boolean handled = moveRabbit( world, rabbit, state );\n\n        if ( handled )\n        {\n            // If we're bridging, we're on a slope\n            rabbit.onSlope = true;\n        }\n\n        return handled;\n    }\n\n    private boolean moveRabbit( World world, Rabbit rabbit, State state )\n    {\n        switch ( state )\n        {\n            case RABBIT_BRIDGING_RIGHT_1:\n            case RABBIT_BRIDGING_RIGHT_2:\n            case RABBIT_BRIDGING_LEFT_1:\n            case RABBIT_BRIDGING_LEFT_2:\n            {\n                bridgeType = BridgeType.ALONG;\n                return true;\n            }\n            case RABBIT_BRIDGING_UP_RIGHT_1:\n            case RABBIT_BRIDGING_UP_RIGHT_2:\n            case RABBIT_BRIDGING_UP_LEFT_1:\n            case RABBIT_BRIDGING_UP_LEFT_2:\n            {\n                bridgeType = BridgeType.UP;\n                return true;\n            }\n            case RABBIT_BRIDGING_DOWN_UP_RIGHT_1:\n            case RABBIT_BRIDGING_DOWN_UP_RIGHT_2:\n            case RABBIT_BRIDGING_DOWN_UP_LEFT_1:\n            case RABBIT_BRIDGING_DOWN_UP_LEFT_2:\n            {\n                bridgeType = BridgeType.DOWN_UP;\n                return true;\n            }\n            case RABBIT_BRIDGING_IN_CORNER_RIGHT_1:\n            case RABBIT_BRIDGING_IN_CORNER_LEFT_1:\n            case RABBIT_BRIDGING_IN_CORNER_RIGHT_2:\n            case RABBIT_BRIDGING_IN_CORNER_LEFT_2:\n            case RABBIT_BRIDGING_IN_CORNER_UP_RIGHT_1:\n            case RABBIT_BRIDGING_IN_CORNER_UP_LEFT_1:\n            case RABBIT_BRIDGING_IN_CORNER_UP_RIGHT_2:\n            case RABBIT_BRIDGING_IN_CORNER_UP_LEFT_2:\n            {\n                bridgeType = BridgeType.ALONG;\n                return true;\n            }\n            case RABBIT_BRIDGING_RIGHT_3:\n            case RABBIT_BRIDGING_DOWN_UP_RIGHT_3:\n            {\n                rabbit.x++;\n                world.changes.addBlock(\n                    new Block(\n                        rabbit.x,\n                        rabbit.y,\n                        EARTH,\n                        BRIDGE_UP_RIGHT,\n                        0\n                    )\n                );\n\n                return true;\n            }\n            case RABBIT_BRIDGING_LEFT_3:\n            case RABBIT_BRIDGING_DOWN_UP_LEFT_3:\n            {\n                rabbit.x--;\n                world.changes.addBlock(\n                    new Block(\n                        rabbit.x,\n                        rabbit.y,\n                        EARTH,\n                        BRIDGE_UP_LEFT,\n                        0\n                    )\n                );\n\n                return true;\n            }\n            case RABBIT_BRIDGING_UP_RIGHT_3:\n            {\n                rabbit.x++;\n                rabbit.y--;\n                world.changes.addBlock(\n                    new Block(\n                        rabbit.x,\n                        rabbit.y,\n                        EARTH,\n                        BRIDGE_UP_RIGHT,\n                        0\n                    )\n                );\n\n                return true;\n            }\n            case RABBIT_BRIDGING_UP_LEFT_3:\n            {\n                rabbit.x--;\n                rabbit.y--;\n                world.changes.addBlock(\n                    new Block(\n                        rabbit.x,\n                        rabbit.y,\n                        EARTH,\n                        BRIDGE_UP_LEFT,\n                        0\n                    )\n                );\n\n                return true;\n            }\n            case RABBIT_BRIDGING_IN_CORNER_RIGHT_3:\n            {\n                rabbit.onSlope = true;\n                world.changes.addBlock(\n                    new Block(\n                        rabbit.x,\n                        rabbit.y,\n                        EARTH,\n                        BRIDGE_UP_RIGHT,\n                        0\n                    )\n                );\n                return true;\n            }\n            case RABBIT_BRIDGING_IN_CORNER_LEFT_3:\n            {\n                rabbit.onSlope = true;\n                world.changes.addBlock(\n                    new Block(\n                        rabbit.x,\n                        rabbit.y,\n                        EARTH,\n                        BRIDGE_UP_LEFT,\n                        0\n                    )\n                );\n                return true;\n            }\n            case RABBIT_BRIDGING_IN_CORNER_UP_RIGHT_3:\n            {\n                rabbit.onSlope = true;\n                rabbit.y--;\n                world.changes.addBlock(\n                    new Block(\n                        rabbit.x,\n                        rabbit.y,\n                        EARTH,\n                        BRIDGE_UP_RIGHT,\n                        0\n                    )\n                );\n                return true;\n            }\n            case RABBIT_BRIDGING_IN_CORNER_UP_LEFT_3:\n            {\n                rabbit.onSlope = true;\n                rabbit.y--;\n                world.changes.addBlock(\n                    new Block(\n                        rabbit.x,\n                        rabbit.y,\n                        EARTH,\n                        BRIDGE_UP_LEFT,\n                        0\n                    )\n                );\n                return true;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n    }\n\n    @Override\n    public void saveState( Map<String, String> saveState )\n    {\n        BehaviourState.addToStateIfNotDefault(\n            saveState,\n            \"Bridging.bridgeType\",\n            bridgeType.toString(),\n            BridgeType.ALONG.toString()\n        );\n\n        BehaviourState.addToStateIfGtZero(\n            saveState, \"Bridging.bigSteps\", bigSteps\n        );\n\n        BehaviourState.addToStateIfGtZero(\n            saveState, \"Bridging.smallSteps\", smallSteps\n        );\n    }\n\n    @Override\n    public void restoreFromState( Map<String, String> saveState )\n    {\n        bridgeType = BridgeType.valueOf(\n            BehaviourState.restoreFromState(\n                saveState, \"Bridging.bridgeType\", bridgeType.toString()\n            )\n        );\n\n        bigSteps = BehaviourState.restoreFromState(\n            saveState, \"Bridging.bigSteps\", bigSteps\n        );\n\n        smallSteps = BehaviourState.restoreFromState(\n            saveState, \"Bridging.smallSteps\", smallSteps\n        );\n\n        if ( smallSteps > 0 )\n        {\n            ++smallSteps;\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/engine/src/rabbitescape/engine/behaviours/Bridging.java b/src/engine/src/rabbitescape/engine/behaviours/Bridging.java
--- a/src/engine/src/rabbitescape/engine/behaviours/Bridging.java	(revision 7242c55f25480b67cdb47d36e279c1a70a1a058f)
+++ b/src/engine/src/rabbitescape/engine/behaviours/Bridging.java	(date 1733742656552)
@@ -19,7 +19,7 @@
         DOWN_UP
     }
 
-    private static Bridging instance;
+    private static volatile Bridging instance;
     private int smallSteps = 0;
     private int bigSteps = 0;
     private BridgeType bridgeType = BridgeType.ALONG;
@@ -27,8 +27,12 @@
     private Bridging(){ }
 
     public static Bridging getInstance() {
-        if (instance == null) {
-            instance = new Bridging();
+        if(instance == null){
+            synchronized ( Bridging.class ){
+                if (instance == null) {
+                    instance = new Blocking();
+                }
+            }
         }
         return instance;
     }
Index: src/engine/src/rabbitescape/engine/behaviours/Bashing.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package rabbitescape.engine.behaviours;\n\nimport static rabbitescape.engine.ChangeDescription.State.*;\nimport static rabbitescape.engine.Direction.*;\nimport static rabbitescape.engine.Token.Type.*;\n\nimport java.util.Map;\n\nimport rabbitescape.engine.*;\nimport rabbitescape.engine.ChangeDescription.State;\n\npublic class Bashing extends Behaviour\n{\n    private int stepsOfBashing;\n    private static Bashing instance;\n\n    private Bashing(){ }\n\n    public static Bashing getInstance() {\n        if (instance == null) {\n            instance = new Bashing();\n        }\n        return instance;\n    }\n\n    public void getVariables(RabbitBehaviourVariables vars) {\n        stepsOfBashing = vars.stepsOfBashing;\n    }\n\n    public void saveVariables(RabbitBehaviourVariables vars)\n    {\n        vars.stepsOfBashing = stepsOfBashing;\n    }\n\n\n    @Override\n    public void cancel()\n    {\n        stepsOfBashing = 0;\n    }\n\n    @Override\n    public boolean checkTriggered( Rabbit rabbit, World world )\n    {\n        BehaviourTools t = BehaviourTools.getInstance( rabbit, world );\n        t.initialize( rabbit, world );\n\n        return t.pickUpToken( bash );\n    }\n\n    @Override\n    public State newState( BehaviourTools t, boolean triggered )\n    {\n        if ( triggered || stepsOfBashing > 0 )\n        {\n            if (\n                   t.isOnUpSlope()\n                && t.blockAboveNext() != null\n            )\n            {\n                if (t.blockAboveNext().material == Block.Material.METAL)\n                {\n                    stepsOfBashing = 0;\n                    return t.rl(\n                        RABBIT_BASHING_USELESSLY_RIGHT_UP,\n                        RABBIT_BASHING_USELESSLY_LEFT_UP\n                        );\n                }\n                else\n                {\n                    stepsOfBashing = 2;\n                    return t.rl(\n                        RABBIT_BASHING_UP_RIGHT,\n                        RABBIT_BASHING_UP_LEFT\n                    );\n                }\n            }\n            else if (\n                t.isOnUpSlope()\n             && t.blockAboveNext() == null\n             && triggered\n            )\n            {\n                return t.rl(\n                    RABBIT_BASHING_USELESSLY_RIGHT_UP,\n                    RABBIT_BASHING_USELESSLY_LEFT_UP\n                );\n            }\n            else if ( t.blockNext() != null )\n            {\n                if ( t.blockNext().material == Block.Material.METAL )\n                {\n                    stepsOfBashing = 0;\n                    return t.rl(\n                        RABBIT_BASHING_USELESSLY_RIGHT,\n                        RABBIT_BASHING_USELESSLY_LEFT\n                    );\n                }\n                else\n                {\n                    stepsOfBashing = 2;\n                    return t.rl(\n                        RABBIT_BASHING_RIGHT,\n                        RABBIT_BASHING_LEFT\n                    );\n                }\n            }\n            else if ( triggered )\n            {\n                return t.rl(\n                    RABBIT_BASHING_USELESSLY_RIGHT,\n                    RABBIT_BASHING_USELESSLY_LEFT\n                );\n            }\n        }\n        --stepsOfBashing;\n        return null;\n    }\n\n    @Override\n    public boolean behave( World world, Rabbit rabbit, State state )\n    {\n\n        switch ( state )\n        {\n            case RABBIT_BASHING_RIGHT:\n            case RABBIT_BASHING_LEFT:\n            {\n                rabbit.slopeBashHop = false;\n                world.changes.removeBlockAt( destX( rabbit ), rabbit.y );\n                return true;\n            }\n            case RABBIT_BASHING_UP_RIGHT:\n            case RABBIT_BASHING_UP_LEFT:\n            {\n                world.changes.removeBlockAt( destX( rabbit ), rabbit.y - 1 );\n                rabbit.slopeBashHop = true;\n                rabbit.y -= 1;\n                return true;\n            }\n            case RABBIT_BASHING_USELESSLY_RIGHT:\n            case RABBIT_BASHING_USELESSLY_LEFT:\n            {\n                rabbit.slopeBashHop = false;\n                return true;\n            }\n            case RABBIT_BASHING_USELESSLY_RIGHT_UP:\n            case RABBIT_BASHING_USELESSLY_LEFT_UP:\n            {\n                rabbit.slopeBashHop = true;\n                rabbit.y -= 1;\n                return true;\n            }\n            default:\n            {\n                rabbit.slopeBashHop = false;\n                return false;\n            }\n        }\n    }\n\n    private int destX( Rabbit rabbit )\n    {\n        return ( rabbit.dir == RIGHT ) ? rabbit.x + 1 : rabbit.x - 1;\n    }\n\n    @Override\n    public void saveState( Map<String, String> saveState )\n    {\n        BehaviourState.addToStateIfGtZero(\n            saveState, \"Bashing.stepsOfBashing\", stepsOfBashing\n        );\n    }\n\n    @Override\n    public void restoreFromState( Map<String, String> saveState )\n    {\n        stepsOfBashing = BehaviourState.restoreFromState(\n            saveState, \"Bashing.stepsOfBashing\", stepsOfBashing\n        );\n\n        if ( stepsOfBashing > 0 )\n        {\n            ++stepsOfBashing;\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/engine/src/rabbitescape/engine/behaviours/Bashing.java b/src/engine/src/rabbitescape/engine/behaviours/Bashing.java
--- a/src/engine/src/rabbitescape/engine/behaviours/Bashing.java	(revision 7242c55f25480b67cdb47d36e279c1a70a1a058f)
+++ b/src/engine/src/rabbitescape/engine/behaviours/Bashing.java	(date 1733742656532)
@@ -12,13 +12,17 @@
 public class Bashing extends Behaviour
 {
     private int stepsOfBashing;
-    private static Bashing instance;
+    private static volatile Bashing instance;
 
     private Bashing(){ }
 
     public static Bashing getInstance() {
-        if (instance == null) {
-            instance = new Bashing();
+        if(instance == null){
+            synchronized ( Bashing.class ){
+                if (instance == null) {
+                    instance = new Bashing();
+                }
+            }
         }
         return instance;
     }
Index: src/engine/src/rabbitescape/engine/Rabbit.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package rabbitescape.engine;\n\nimport static rabbitescape.engine.ChangeDescription.State.*;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport rabbitescape.engine.ChangeDescription.State;\nimport rabbitescape.engine.behaviours.*;\n\npublic class Rabbit extends Thing implements Comparable<Rabbit>\n{\n    public static enum Type\n    {\n        RABBIT,\n        RABBOT\n    }\n\n    public final static int NOT_INDEXED = 0;\n    protected final List<Behaviour> behaviours;\n    protected final List<Behaviour> behavioursTriggerOrder;\n\n    public int index;\n\n    private Falling falling;\n\n    public Direction dir;\n    public boolean onSlope;\n    /** Rabbits move up 1 cell to bash from a slope.\n     *  Keep a note, so it can be undone.  */\n    public boolean slopeBashHop = false;\n    public final Type type;\n\n    public RabbitBehaviourVariables behaviourVariables;\n\n    public Rabbit( int x, int y, Direction dir, Type type )\n    {\n        super( x, y, RABBIT_WALKING_LEFT );\n        this.dir = dir;\n        this.onSlope = false;\n        this.type = type;\n        behaviours = new ArrayList<>();\n        behavioursTriggerOrder = new ArrayList<>();\n        createBehaviours();\n        index = NOT_INDEXED;\n        behaviourVariables = new RabbitBehaviourVariables(getFatalHeight());\n    }\n\n    private void createBehaviours()\n    {\n        List<Behaviour> behaviourList = BehaviourList.createRabbitBehaviours();\n        this.behaviours.addAll(behaviourList);\n        this.behavioursTriggerOrder.addAll(behaviourList);\n        assert behavioursTriggerOrder.size() == behaviours.size();\n    }\n\n    public boolean isFallingToDeath()\n    {\n        falling = Falling.getInstance();\n        falling.getVariables( behaviourVariables );\n        boolean fallingToDeath = falling.isFallingToDeath();\n        falling.saveVariables( behaviourVariables );\n\n        return fallingToDeath;\n    }\n\n    @Override\n    public void calcNewState( World world )\n    {\n        for ( Behaviour behaviour : behavioursTriggerOrder )\n        {\n            behaviour.triggered = false;\n        }\n\n        for ( Behaviour behaviour : behavioursTriggerOrder )\n        {\n            behaviour.getVariables( behaviourVariables );\n            behaviour.triggered = behaviour.checkTriggered( this, world );\n            behaviour.saveVariables( behaviourVariables );\n            if ( behaviour.triggered )\n            {\n                cancelAllBehavioursExcept( behaviour );\n            }\n        }\n\n        boolean done = false;\n        for ( Behaviour behaviour : behaviours )\n        {\n            BehaviourTools b = BehaviourTools.getInstance( this, world );\n            b.initialize( this, world );\n            behaviour.getVariables( behaviourVariables );\n            State thisState = behaviour.newState(\n                new BehaviourTools( this, world ), behaviour.triggered );\n            behaviour.saveVariables( behaviourVariables );\n            if ( thisState != null && !done )\n            {\n                state = thisState;\n                done = true;\n            }\n        }\n\n    }\n\n    private void cancelAllBehavioursExcept( Behaviour exception )\n    {\n        for ( Behaviour behaviour : behaviours )\n        {\n            if ( behaviour != exception )\n            {\n                behaviour.getVariables( behaviourVariables );\n                behaviour.cancel();\n                behaviour.saveVariables( behaviourVariables );\n            }\n        }\n    }\n\n    public void possiblyUndoSlopeBashHop( World world )\n    {\n        if ( !slopeBashHop )\n        {\n            return;\n        }\n        BehaviourTools t = BehaviourTools.getInstance( this, world );\n        t.initialize( this, world );\n        if ( t.blockHere() != null ||\n            !BehaviourTools.isSlope( t.blockBelow() ) )\n        {\n            return;\n        }\n        ++y;\n        slopeBashHop = false;\n    }\n\n    @Override\n    public void step( World world )\n    {\n        for ( Behaviour behaviour : behaviours )\n        {\n            behaviour.getVariables( behaviourVariables );\n            boolean handled = behaviour.behave( world, this, state );\n            behaviour.saveVariables( behaviourVariables );\n            if ( handled )\n            {\n                break;\n            }\n        }\n    }\n\n    @Override\n    public Map<String, String> saveState( boolean runtimeMeta )\n    {\n        Map<String, String> ret = new HashMap<String, String>();\n        if ( !runtimeMeta )\n        {\n            return ret;\n        }\n\n        BehaviourState.addToStateIfGtZero( ret, \"index\", index );\n        BehaviourState.addToStateIfTrue( ret, \"onSlope\", onSlope );\n\n        for ( Behaviour behaviour : behaviours )\n        {\n            behaviour.getVariables( behaviourVariables );\n            behaviour.saveState( ret );\n            behaviour.saveVariables( behaviourVariables );\n        }\n\n        return ret;\n    }\n\n    @Override\n    public void restoreFromState( Map<String, String> state )\n    {\n        index = BehaviourState.restoreFromState( state, \"index\", -1 );\n\n        onSlope = BehaviourState.restoreFromState(\n            state, \"onSlope\", false\n        );\n\n        for ( Behaviour behaviour : behaviours )\n        {\n            behaviour.getVariables( behaviourVariables );\n            behaviour.restoreFromState( state );\n            behaviour.saveVariables( behaviourVariables );\n        }\n    }\n\n    @Override\n    public String overlayText()\n    {\n        String fmt;\n        switch ( dir )\n        {\n        case LEFT:\n            fmt = \"<[%d] \";\n            break;\n        case RIGHT:\n            fmt = \" [%d]>\";\n            break;\n        default:\n            throw new RuntimeException( \"Rabbit should only be left or right\");\n        }\n        return String.format( fmt, index ) ;\n    }\n\n    @Override\n    public int compareTo( Rabbit r )\n    {\n        return this.index - r.index;\n    }\n\n    @Override\n    public boolean equals( Object o )\n    {\n        if ( null == o || !( o instanceof Rabbit ) )\n        {\n            return false;\n        }\n        return ( (Rabbit)o ).index == this.index;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return index;\n    }\n\n    @Override\n    public String stateName()\n    {\n        String normalName = super.stateName();\n        if ( type == Type.RABBIT )\n        {\n            return normalName;\n        }\n        else\n        {\n            return normalName.replaceFirst(\n                \"^rabbit\", type.name().toLowerCase() );\n        }\n    }\n\n    /** Rabbots can fall further than rabbits. */\n    private int getFatalHeight()\n    {\n        return ( type == Type.RABBIT ? 4 : 5 );\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/engine/src/rabbitescape/engine/Rabbit.java b/src/engine/src/rabbitescape/engine/Rabbit.java
--- a/src/engine/src/rabbitescape/engine/Rabbit.java	(revision 7242c55f25480b67cdb47d36e279c1a70a1a058f)
+++ b/src/engine/src/rabbitescape/engine/Rabbit.java	(date 1733742656548)
@@ -92,7 +92,7 @@
             b.initialize( this, world );
             behaviour.getVariables( behaviourVariables );
             State thisState = behaviour.newState(
-                new BehaviourTools( this, world ), behaviour.triggered );
+                b, behaviour.triggered );
             behaviour.saveVariables( behaviourVariables );
             if ( thisState != null && !done )
             {
Index: src/engine/src/rabbitescape/engine/behaviours/Blocking.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package rabbitescape.engine.behaviours;\n\nimport static rabbitescape.engine.ChangeDescription.State.*;\nimport static rabbitescape.engine.Token.Type.*;\n\nimport java.util.Map;\n\nimport rabbitescape.engine.*;\nimport rabbitescape.engine.ChangeDescription.State;\n\npublic class Blocking extends Behaviour\n{\n    public boolean abilityActive = false;\n    private static Blocking instance;\n\n    private Blocking(){ }\n\n    public static Blocking getInstance() {\n        if (instance == null) {\n            instance = new Blocking();\n        }\n        return instance;\n    }\n\n    public void getVariables(RabbitBehaviourVariables vars) {\n        abilityActive = vars.abilityActive_blocking;\n    }\n\n    public void saveVariables(RabbitBehaviourVariables vars)\n    {\n        vars.abilityActive_blocking = abilityActive;\n    }\n\n\n    @Override\n    public void cancel()\n    {\n        abilityActive = false;\n    }\n\n    @Override\n    public boolean checkTriggered( Rabbit rabbit, World world )\n    {\n        BehaviourTools t = BehaviourTools.getInstance( rabbit, world );\n        t.initialize( rabbit, world );\n        return t.pickUpToken( block );\n    }\n\n    @Override\n    public State newState( BehaviourTools t, boolean triggered )\n    {\n        if ( abilityActive || triggered )\n        {\n            t.rabbit.possiblyUndoSlopeBashHop( t.world );\n            abilityActive = true;\n            Block here = t.blockHere();\n            if( BehaviourTools.isRightRiseSlope( here ) )\n            {\n                return RABBIT_BLOCKING_RISE_RIGHT;\n            }\n            else if ( BehaviourTools.isLeftRiseSlope( here ) )\n            {\n                return RABBIT_BLOCKING_RISE_LEFT;\n            }\n            else\n            {\n                return RABBIT_BLOCKING;\n            }\n        }\n\n        return null;\n    }\n\n    @Override\n    public boolean behave( World world, Rabbit rabbit, State state )\n    {\n        return isBlocking( state );\n    }\n\n    @Override\n    public void saveState( Map<String, String> saveState )\n    {\n        BehaviourState.addToStateIfTrue(\n            saveState, \"Blocking.abilityActive\", abilityActive\n        );\n    }\n\n    @Override\n    public void restoreFromState( Map<String, String> saveState )\n    {\n        abilityActive = BehaviourState.restoreFromState(\n            saveState, \"Blocking.abilityActive\", abilityActive\n        );\n    }\n\n    public static boolean blockerAt( World world, int nextX, int nextY )\n    {\n        Rabbit[] rabbits = world.getRabbitsAt( nextX, nextY );\n        for ( Rabbit r : rabbits )\n        {\n            if ( isBlocking( r.state ) )\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    static boolean isBlocking( State s )\n    {\n        switch ( s ) {\n        case RABBIT_BLOCKING:\n        case RABBIT_BLOCKING_RISE_RIGHT:\n        case RABBIT_BLOCKING_RISE_LEFT:\n            return true;\n        default:\n            return false;\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/engine/src/rabbitescape/engine/behaviours/Blocking.java b/src/engine/src/rabbitescape/engine/behaviours/Blocking.java
--- a/src/engine/src/rabbitescape/engine/behaviours/Blocking.java	(revision 7242c55f25480b67cdb47d36e279c1a70a1a058f)
+++ b/src/engine/src/rabbitescape/engine/behaviours/Blocking.java	(date 1733742656540)
@@ -11,13 +11,17 @@
 public class Blocking extends Behaviour
 {
     public boolean abilityActive = false;
-    private static Blocking instance;
+    private static volatile Blocking instance;
 
     private Blocking(){ }
 
     public static Blocking getInstance() {
-        if (instance == null) {
-            instance = new Blocking();
+        if(instance == null){
+            synchronized ( Blocking.class ){
+                if (instance == null) {
+                    instance = new Blocking();
+                }
+            }
         }
         return instance;
     }
Index: src/engine/src/rabbitescape/engine/BehaviourTools.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package rabbitescape.engine;\n\nimport static rabbitescape.engine.Block.Shape.*;\nimport static rabbitescape.engine.Direction.RIGHT;\nimport static rabbitescape.engine.Direction.opposite;\n\nimport rabbitescape.engine.state.*;\nimport rabbitescape.engine.state.RabbitStateTemplate;\nimport rabbitescape.engine.util.Position;\n\npublic class BehaviourTools\n{\n    private static BehaviourTools instance;\n    public Rabbit rabbit;\n    public World world;\n\n    private BehaviourTools(){}\n\n    public BehaviourTools( Rabbit rabbit, World world )\n    {\n        this.rabbit = rabbit;\n        this.world = world;\n    }\n\n    public static BehaviourTools getInstance(Rabbit rabbit, World world){\n        if(instance == null) {\n            instance = new BehaviourTools(rabbit, world);\n        }\n        return instance;\n    }\n\n    public void initialize(Rabbit rabbit, World world){\n        this.rabbit = rabbit;\n        this.world = world;\n    }\n\n    public ChangeDescription.State rl(\n        ChangeDescription.State rightState,\n        ChangeDescription.State leftState\n    )\n    {\n        return rabbit.dir == RIGHT ? rightState : leftState;\n    }\n\n    public boolean pickUpToken( Token.Type type )\n    {\n        return pickUpToken( type, false );\n    }\n\n    public boolean rabbitTemplate(RabbitStateTemplate stateTemplate) {\n        return stateTemplate.checkState(rabbit);\n    }\n\n    public boolean rabbitIsFalling() {\n        return rabbitTemplate(new FallingState());\n    }\n\n    public boolean rabbitIsClimbing() {\n        return rabbitTemplate(new ClimbingState());\n    }\n\n    public boolean rabbitIsBashing() {\n        return rabbitTemplate(new BashingState());\n    }\n\n    /**\n     * Checks for the presence of a token. Removes token from the world\n     * and returns true if a token is being picked up.\n     */\n    public boolean pickUpToken( Token.Type type, boolean evenIfNotOnGround )\n    {\n        if ( rabbitIsFalling() && rabbit.isFallingToDeath() )\n        {\n            return false; // Dying rabbits not allowed to consume tokens\n        }\n\n        if ( evenIfNotOnGround || onGround() )\n        {\n            Token token = world.getTokenAt( rabbit.x, rabbit.y );\n            if ( token != null && token.type == type )\n            {\n                world.changes.removeToken( token );\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public Block blockHere()\n    {\n        return world.getBlockAt( rabbit.x, rabbit.y );\n    }\n\n    public Block blockNext()\n    {\n        return world.getBlockAt( nextX(), rabbit.y );\n    }\n\n    public Block blockBelow()\n    {\n        return world.getBlockAt( rabbit.x, rabbit.y + 1 );\n    }\n\n    public Block block2Below()\n    {\n        return world.getBlockAt( rabbit.x, rabbit.y + 2 );\n    }\n\n    public Block blockBelowNext()\n    {\n        return world.getBlockAt( nextX(), rabbit.y + 1 );\n    }\n\n    public Block blockAbove()\n    {\n        return world.getBlockAt( rabbit.x, rabbit.y - 1 );\n    }\n\n    public Block blockAboveNext()\n    {\n        return world.getBlockAt( nextX(), rabbit.y - 1 );\n    }\n\n    private boolean onGround()\n    {\n        return ( rabbit.onSlope || blockBelow() != null );\n    }\n\n    public boolean isWall( Block block )\n    {\n        return (\n               block != null\n            && (\n                   block.shape == FLAT\n                || (\n                    block.riseDir() == opposite( rabbit.dir )\n                    && isSolid( block )\n                )\n            )\n        );\n    }\n\n\n    public static boolean shapeEquals( Block b, Block.Shape s )\n    {\n        if ( null == b )\n        {\n            return false;\n        }\n        return s == b.shape;\n    }\n\n    public static boolean isRightRiseSlope( Block b )\n    {\n        if( b == null )\n        {\n            return false;\n        }\n        return b.shape == UP_RIGHT\n            || b.shape == BRIDGE_UP_RIGHT;\n    }\n\n    public static boolean isLeftRiseSlope( Block b )\n    {\n        if( b == null )\n        {\n            return false;\n        }\n        return b.shape == UP_LEFT\n            || b.shape == BRIDGE_UP_LEFT;\n    }\n\n    public static boolean isSlope( Block b )\n    {\n        return isRightRiseSlope( b ) || isLeftRiseSlope( b );\n    }\n\n    public static boolean isBridge( Block b )\n    {\n        if( b == null )\n        {\n            return false;\n        }\n        switch ( b.shape )\n        {\n        case BRIDGE_UP_LEFT:\n        case BRIDGE_UP_RIGHT:\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    public static boolean isSolid( Block block )\n    {\n        return (\n               block.shape == FLAT\n            || block.shape == UP_LEFT\n            || block.shape == UP_RIGHT\n        );\n    }\n\n    public boolean isRoof( Block block )\n    {\n        return\n            (\n                block != null\n                && (\n                       block.shape == FLAT\n                    || block.shape == UP_LEFT\n                    || block.shape == UP_RIGHT\n                )\n            );\n    }\n\n    public boolean isOnSlopeStateUnreliable()\n    {\n        Block block = blockHere();\n        return\n            null != block &&\n            (\n                   block.shape == UP_LEFT\n                || block.shape == UP_RIGHT\n                || block.shape == BRIDGE_UP_LEFT\n                || block.shape == BRIDGE_UP_RIGHT\n            );\n    }\n\n    public boolean isFlat( Block block )\n    {\n        return s_isFlat( block );\n    }\n\n    public static boolean s_isFlat( Block block )\n    {\n        return ( block != null && block.shape == FLAT );\n    }\n\n    private boolean goingUpSlope()\n    {\n        if ( rabbit.onSlope )\n        {\n            if( isOnUpSlope() )\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean isOnUpSlope()\n    {\n        return rabbit.onSlope && hereIsUpSlope();\n    }\n\n    /**\n     * Check if rabbit is changing from an up slope directly to a down slope.\n     */\n    public boolean isCresting()\n    {\n        // block where slope would be if it continues\n        Block contBlock = world.getBlockAt( nextX(), nextY() );\n        Block belowContBlock = world.getBlockAt( nextX(), nextY() + 1 );\n\n        return isOnUpSlope() &&\n               null == contBlock &&\n               isDownSlope( belowContBlock );\n    }\n\n    /**\n     * Check if rabbit is changing from a down slope directly to an up slope.\n     */\n    public boolean isValleying()\n    {\n        // block where slope would be if it continues\n        Block alongBlock = world.getBlockAt( nextX(), rabbit.y );\n\n        return isOnDownSlope() &&\n               isUpSlope( alongBlock );\n    }\n\n    public boolean hereIsUpSlope()\n    {\n        return isUpSlope( blockHere() );\n    }\n\n    public boolean isUpSlope( Block block )\n    {\n        return ( block != null && block.riseDir() == rabbit.dir );\n    }\n\n    public boolean isOnDownSlope()\n    {\n        return rabbit.onSlope && hereIsDownSlope();\n    }\n\n    private boolean hereIsDownSlope()\n    {\n        return isDownSlope( blockHere() );\n    }\n\n    public boolean isDownSlope( Block block )\n    {\n        return ( block != null && block.riseDir() == opposite( rabbit.dir ) );\n    }\n\n    public static boolean isSlopeNotBridge( Block b )\n    {\n        if ( null == b )\n        {\n            return false;\n        }\n        switch( b.shape )\n        {\n        case UP_LEFT:\n        case UP_RIGHT:\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    public int nextX()\n    {\n        return\n            rabbit.x + (\n                rabbit.dir == RIGHT ? 1 : -1\n            );\n    }\n\n    public int nextY()\n    {\n        if ( goingUpSlope() )\n        {\n            return rabbit.y - 1;\n        }\n        else\n        {\n            return rabbit.y;\n        }\n    }\n\n    /**\n     * @brief A rabbit may be on a slope block as a digger\n     *        or basher removes it. This is here to make sure\n     *        they fall.\n     */\n    public boolean blockHereJustRemoved()\n    {\n        for ( Position p : world.changes.blocksJustRemoved )\n        {\n            if ( rabbit.x == p.x && rabbit.y == p.y )\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/engine/src/rabbitescape/engine/BehaviourTools.java b/src/engine/src/rabbitescape/engine/BehaviourTools.java
--- a/src/engine/src/rabbitescape/engine/BehaviourTools.java	(revision 7242c55f25480b67cdb47d36e279c1a70a1a058f)
+++ b/src/engine/src/rabbitescape/engine/BehaviourTools.java	(date 1733742656544)
@@ -10,7 +10,7 @@
 
 public class BehaviourTools
 {
-    private static BehaviourTools instance;
+    private static volatile BehaviourTools instance;
     public Rabbit rabbit;
     public World world;
 
@@ -24,7 +24,11 @@
 
     public static BehaviourTools getInstance(Rabbit rabbit, World world){
         if(instance == null) {
-            instance = new BehaviourTools(rabbit, world);
+            synchronized ( BehaviourTools.class )
+            {
+                if ( instance == null )
+                    instance = new BehaviourTools( rabbit, world );
+            }
         }
         return instance;
     }
